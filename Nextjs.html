<!DOCTYPE html>
<html lang="ko">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>

<body>
	<h1>Server Components</h1>

	<p>React 서버 컴포넌트(React Server Components)를 사용하면 서버에서 렌더링되고 선택적으로 캐시할 수 있는 UI를 작성할 수 있습니다. Next.js에서는 렌더링 작업이 경로 세그먼트로 분할되어 스트리밍 및 부분 렌더링을 가능하게 하며, 세 가지 다른 서버 렌더링 전략이 있습니다:</p>

	<ul>
		<li>정적 렌더링 (Static Rendering)</li>
		<li>동적 렌더링 (Dynamic Rendering)</li>
		<li>스트리밍 (Streaming)</li>
	</ul>
	<p>이 페이지에서는 서버 컴포넌트의 작동 방식, 사용 사례, 그리고 다양한 서버 렌더링 전략에 대해 설명합니다.</p>
	<div>
		<h2>Benefits of Server Rendering</h2>
		<div>
			<p>서버에서 렌더링 작업을 수행하는 데는 여러 가지 이점이 있습니다. 여기에는 다음이 포함됩니다:</p>
			<ul>
				<li>
					<p><strong>데이터 가져오기</strong>: 서버 컴포넌트를 사용하면 데이터 가져오기를 데이터 소스에 더 가까운 서버로 이동할 수 있습니다. 이를 통해 렌더링에 필요한 데이터를 가져오는 시간이 단축되고, 클라이언트에서 요청해야 하는 횟수가 줄어들어 성능이 향상될 수 있습니다.</p>
				</li>
				<li>
					<p><strong>보안</strong>: 서버 컴포넌트를 사용하면 토큰이나 API 키와 같은 민감한 데이터와 로직을 클라이언트에 노출시키지 않고 서버에 유지할 수 있습니다.</p>
				</li>
				<li>
					<p><strong>캐싱</strong>: 서버에서 렌더링함으로써 결과를 캐시하고 이후 요청 및 사용자 간에 재사용할 수 있습니다. 이를 통해 각 요청 시 수행해야 하는 렌더링 및 데이터 가져오기 작업을 줄여 성능을 향상시키고 비용을 절감할 수 있습니다.</p>
				</li>
				<li>
					<p><strong>성능</strong>: 서버 컴포넌트는 기본 성능을 최적화할 수 있는 추가 도구를 제공합니다. 예를 들어, 전체 클라이언트 컴포넌트로 구성된 앱에서 비인터랙티브 UI 부분을 서버 컴포넌트로 이동하면 클라이언트 측에서 필요한 JavaScript의 양을 줄일 수 있습니다. 이는 느린 인터넷이나 성능이 낮은 장치를 사용하는 사용자에게 유리합니다. 브라우저가 다운로드, 파싱 및 실행해야 할 클라이언트 측 JavaScript의 양이 줄어들기 때문입니다.</p>
				</li>
				<li>
					<p><strong>초기 페이지 로드 및 첫 번째 의미 있는 페인트(FCP)</strong>: 서버에서는 HTML을 생성하여 사용자가 클라이언트가 페이지를 렌더링하는 데 필요한 JavaScript를 다운로드, 파싱 및 실행할 때까지 기다리지 않고 즉시 페이지를 볼 수 있도록 할 수 있습니다.</p>
				</li>
				<li>
					<p><strong>검색 엔진 최적화 및 소셜 네트워크 공유성</strong>: 렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱싱하고 소셜 네트워크 봇이 페이지에 대한 소셜 카드 미리보기를 생성하는 데 사용될 수 있습니다.</p>
				</li>
				<li>
					<p><strong>스트리밍</strong>: 서버 컴포넌트를 사용하면 렌더링 작업을 여러 청크로 분할하여 준비되는 대로 클라이언트에 스트리밍할 수 있습니다. 이를 통해 전체 페이지가 서버에서 렌더링될 때까지 기다리지 않고도 사용자가 페이지의 일부를 더 일찍 볼 수 있습니다.</p>
				</li>
			</ul>
		</div>
		<h2>Using Server Components in Next.js</h2>
		<div>
			<p>
				기본적으로 Next.js는 서버 컴포넌트를 사용합니다. 이를 통해 추가 구성 없이 자동으로 서버 렌더링을 구현할 수 있으며, 필요한 경우 클라이언트 컴포넌트를 사용할 수 있습니다. 클라이언트 컴포넌트에 대한 자세한 내용은 클라이언트 컴포넌트를 참조하십시오.
			</p>
		</div>
		<h2>How are Server Components rendered?</h2>
		<div>
			<p>서버에서 Next.js는 React의 API를 사용하여 렌더링을 조정합니다. 렌더링 작업은 개별 경로 세그먼트와 Suspense 경계를 기준으로 청크로 분할됩니다.</p>

			<p>각 청크는 두 단계로 렌더링됩니다:</p>

			<ol>
				<li>
					<p>React는 서버 컴포넌트를 특수한 데이터 형식인 React 서버 컴포넌트 페이로드(RSC 페이로드)로 렌더링합니다.</p>
				</li>
				<p>
					<li>Next.js는 RSC 페이로드와 클라이언트 컴포넌트 JavaScript 지침을 사용하여 서버에서 HTML을 렌더링합니다.</li>
				</p>
			</ol>
			<p>그런 다음 클라이언트에서:</p>

			<ol>
				<li>
					<p>HTML은 경로의 빠른 비대화형 미리보기를 즉시 표시하는 데 사용됩니다. 이는 초기 페이지 로드에만 해당됩니다.</p>
				</li>
				<li>
					<p>React 서버 컴포넌트 페이로드(RSC 페이로드)는 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트하는 데 사용됩니다.</p>
				</li>
				<li>
					<p>JavaScript 지침은 클라이언트 컴포넌트를 활성화하여 애플리케이션을 대화형으로 만듭니다.</p>
				</li>
			</ol>
			<div>
				<p><strong>React 서버 컴포넌트 페이로드(RSC 페이로드)란 무엇인가요?</strong></p>
				<p>RSC 페이로드는 렌더링된 React 서버 컴포넌트 트리의 간결한 이진 표현입니다. 이는 클라이언트에서 React가 브라우저의 DOM을 업데이트하는 데 사용됩니다. RSC 페이로드에는 다음이 포함됩니다:</p>
				<ul>
					<li>서버 컴포넌트의 렌더링 결과</li>
					<li>클라이언트 컴포넌트가 렌더링되어야 할 위치에 대한 자리 표시자와 해당 JavaScript 파일에 대한 참조</li>
					<li>서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props</li>
				</ul>
			</div>
		</div>
		<h2>Server Rendering Strategies</h2>
		<div>
			<p>서버 렌더링에는 세 가지 하위 집합이 있습니다: 정적 렌더링, 동적 렌더링, 그리고 스트리밍입니다.</p>
<div>

				<h3>정적 렌더링 (기본값)</h3>
				<div>
					<p>정적 렌더링에서는 경로가 빌드 시 또는 데이터 재검증 후 백그라운드에서 렌더링됩니다. 그 결과는 캐시되어 콘텐츠 전송 네트워크(CDN)에 푸시될 수 있습니다. 이 최적화는 렌더링 작업의 결과를 사용자와 서버 요청 간에 공유할 수 있게 합니다.</p>
					<p>정적 렌더링은 사용자에게 맞춤화되지 않고 빌드 시에 알 수 있는 데이터를 가진 경로에 유용합니다. 예를 들어, 정적 블로그 게시물이나 제품 페이지가 해당됩니다.</p>
				</div>

				<h3>동적 렌더링</h3>
				<div>
					<p>동적 렌더링에서는 경로가 각 사용자 요청 시에 렌더링됩니다.</p>
					<p>동적 렌더링은 사용자에게 맞춤화된 데이터나 요청 시에만 알 수 있는 정보를 가진 경로에 유용합니다. 예를 들어, 쿠키나 URL의 검색 매개변수 등이 해당됩니다.</p>
				</div>

				<fieldset>
					<strong>캐시된 데이터를 사용하는 동적 경로</strong>
					<p>대부분의 웹사이트에서 경로는 완전히 정적이거나 완전히 동적이지 않습니다. 예를 들어, 재검증 간격으로 캐시된 제품 데이터를 사용하는 전자 상거래 페이지가 있지만, 개인 맞춤화된 고객 데이터는 캐시되지 않은 경우가 있습니다.</p>

					<p>Next.js에서는 캐시된 데이터와 캐시되지 않은 데이터를 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있습니다. 이는 RSC 페이로드와 데이터가 별도로 캐시되기 때문입니다. 이를 통해 모든 데이터를 요청 시에 가져오는 성능 영향을 걱정하지 않고 동적 렌더링을 선택할 수 있습니다.</p>

					<p>전체 경로 캐시 및 데이터 캐시에 대한 자세한 내용은 여기에서 확인할 수 있습니다.</p>
				</fieldset>

				<h4>동적 렌더링으로 전환하기</h4>
				<p>렌더링 중에 동적 함수나 캐시되지 않은 데이터 요청이 발견되면, Next.js는 전체 경로를 동적으로 렌더링하도록 전환합니다. 이 표는 동적 함수와 데이터 캐시가 경로가 정적으로 또는 동적으로 렌더링되는지에 미치는 영향을 요약한 것입니다:</p>

				<table border="1">
					<thead>
						<tr><th>동적 함수</th>	<th>데이터</th>	<th>경로</th></tr>
					</thead>
					<tbody>
						<tr><td>아니오</td>	<td>캐시됨</td>	<td>정적 렌더링</td></tr>
						<tr><td>예</td>	<td>캐시됨</td>	<td>동적 렌더링</td></tr>
						<tr><td>아니오</td>	<td>캐시되지 않음</td>	<td>동적 렌더링</td></tr>
						<tr><td>예</td>	<td>캐시되지 않음</td>	<td>동적 렌더링</td></tr>
					</tbody>
				</table>
				<p>위 표에서, 경로가 완전히 정적이 되려면 모든 데이터가 캐시되어야 합니다. 그러나 캐시된 데이터 가져오기와 캐시되지 않은 데이터 가져오기를 모두 사용하는 동적으로 렌더링된 경로를 가질 수 있습니다.</p>

				<p>개발자로서, 정적 렌더링과 동적 렌더링 중에서 선택할 필요는 없습니다. Next.js는 사용된 기능과 API를 기반으로 각 경로에 가장 적합한 렌더링 전략을 자동으로 선택합니다. 대신, 특정 데이터를 언제 캐시하거나 재검증할지 선택하고, UI의 일부를 스트리밍할지 선택할 수 있습니다.</p>

				<h4>동적 함수</h4>
				<td>동적 함수는 사용자 쿠키, 현재 요청 헤더 또는 URL의 검색 매개변수와 같이 요청 시에만 알 수 있는 정보에 의존합니다. Next.js에서 이러한 동적 함수는 다음과 같습니다:</td>

				<ul>
					<li>cookies() 및 headers(): 서버 컴포넌트에서 이를 사용하면 전체 경로가 요청 시 동적으로 렌더링됩니다.</li>
					<li>searchParams: 페이지에서 searchParams prop을 사용하면 페이지가 요청 시 동적으로 렌더링됩니다.</li>
				</ul>
				<p>이러한 함수를 사용하면 전체 경로가 요청 시 동적으로 렌더링됩니다.</p>

				<h3>스트리밍</h3>
				<p>스트리밍은 서버에서 UI를 점진적으로 렌더링할 수 있게 합니다. 작업은 여러 청크로 나뉘어 준비되는 대로 클라이언트에 스트리밍됩니다. 이를 통해 사용자는 전체 콘텐츠가 렌더링되기 전에 페이지의 일부를 즉시 볼 수 있습니다.</p>

				<p>스트리밍은 기본적으로 Next.js 앱 라우터에 내장되어 있습니다. 이는 초기 페이지 로딩 성능과 전체 경로 렌더링을 차단하는 느린 데이터 가져오기에 의존하는 UI를 모두 개선하는 데 도움이 됩니다. 예를 들어, 제품 페이지의 리뷰가 해당됩니다.</p>

				<p>스트리밍 경로 세그먼트를 loading.js 및 React Suspense를 사용한 UI 컴포넌트를 사용하여 시작할 수 있습니다. 자세한 내용은 로딩 UI 및 스트리밍 섹션을 참조하십시오.</p>
</div>
		</div>
	</div>
</body>

</html>